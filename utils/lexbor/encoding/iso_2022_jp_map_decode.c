/*
 * Copyright (C) 2019 Alexander Borisov
 *
 * Author: Alexander Borisov <borisov@lexbor.com>
 */

#include "lexbor/encoding/encoding.h"
#include "lexbor/encoding/encode.h"
#include "lexbor/encoding/multi.h"


#define append_to_file(fc, data, len, codepoint)                               \
    do {                                                                       \
        lxb_char_t *data_to = data;                                            \
                                                                               \
        for (size_t j = 0; j < len; j++) {                                     \
            fprintf(fc, "\\x%02X", (unsigned) data_to[j]);                     \
        }                                                                      \
                                                                               \
        fprintf(fc, " 0x%04X\n", (unsigned) codepoint);                        \
    }                                                                          \
    while (0)

#define encode_to_file(fc, ref, end, cp)                                       \
    do {                                                                       \
        memset(&ctx, 0, sizeof(lxb_encoding_encode_t));                        \
                                                                               \
        len = enc_data->encode(&ctx, &ref, end, cp);                           \
        if (len < LXB_ENCODING_ENCODE_OK) {                                    \
            printf("Failed to encoding code point: %u\n", cp);                 \
            return EXIT_FAILURE;                                               \
        }                                                                      \
                                                                               \
        len_eof = lxb_encoding_encode_iso_2022_jp_eof(&ctx, &ref,              \
                                                      ref + (end - ref));      \
        if (len_eof < LXB_ENCODING_ENCODE_OK) {                                \
            printf("Failed to encoding code point: %u\n", cp);                 \
            return EXIT_FAILURE;                                               \
        }                                                                      \
                                                                               \
        ref -= len + len_eof;                                                  \
        append_to_file(fc, ref, len + len_eof, cp);                            \
    }                                                                          \
    while (0)


int main(int argc, const char * argv[])
{
    size_t size;
    int8_t len, len_eof;
    lxb_encoding_encode_t ctx;
    const lxb_encoding_data_t *enc_data;
    const lxb_encoding_multi_index_t *entry;

    lxb_char_t data[12];
    lxb_char_t *ref = data;
    const lxb_char_t *end = data + sizeof(data);

    const char *filepath = "./iso_2022_jp_map_decode.txt";

    enc_data = lxb_encoding_data(LXB_ENCODING_ISO_2022_JP);

    FILE *fc = fopen(filepath, "w");
    if (fc == NULL) {
        printf("Failed to opening file: %s\n", filepath);
        exit(EXIT_FAILURE);
    }

    fprintf(fc, "#\n"
            "# Copyright (C) 2019 Alexander Borisov\n"
            "#\n"
            "# Author: Alexander Borisov <borisov@lexbor.com>\n"
            "#\n\n");

    fprintf(fc, "#\n"
            "# This file generated by the program\n"
            "# \"utils/lexbor/encoding/iso_2022_jp_map_decode.c\"\n"
            "#\n\n");

    for (lxb_codepoint_t i = 0x00; i < 0x80; i++) {
        if (i == 0x0E || i == 0x0F || i == 0x1B) {
            continue;
        }

        encode_to_file(fc, ref, end, i);
    }

    /* Single index */
    size = sizeof(lxb_encoding_multi_index_iso_2022_jp_katakana)
           / sizeof(lxb_encoding_multi_index_t);

    for (size_t i = 0; i < size; i++) {
        entry = &lxb_encoding_multi_index_iso_2022_jp_katakana[i];

        if (entry->codepoint > LXB_ENCODING_DECODE_MAX_CODEPOINT) {
            continue;
        }

        encode_to_file(fc, ref, end, entry->codepoint);
    }

    for (lxb_codepoint_t i = 0xFF61; i <= 0xFF9F; i++) {
        encode_to_file(fc, ref, end, i);
    }

    size = sizeof(lxb_encoding_multi_index_jis0208)
           / sizeof(lxb_encoding_multi_index_t);

    for (size_t i = 0; i < size; i++) {
        entry = &lxb_encoding_multi_index_jis0208[i];

        if (entry->codepoint > LXB_ENCODING_DECODE_MAX_CODEPOINT) {
            continue;
        }

        encode_to_file(fc, ref, end, entry->codepoint);
    }

    encode_to_file(fc, ref, end, 0x2212);
    encode_to_file(fc, ref, end, 0xFF0D);
    encode_to_file(fc, ref, end, 0x203E);
    encode_to_file(fc, ref, end, 0x00A5);

    fprintf(fc, "\n# END\n");

    fclose(fc);

    return EXIT_SUCCESS;
}
