#!/usr/bin/perl

#############################################################
# Copyright (C) 2025-2026 Alexander Borisov
#
# Author: Alexander Borisov <borisov@lexbor.com>
#
# This file is part of Lexbor.
##############################################################

use utf8;
use strict;
use FindBin;
use File::Spec::Functions;
use Getopt::Long;
use warnings FATAL => 'all';

binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");

unless (@ARGV) {
    help_message();
    exit 0;
}

# Global variables
my $ALL = 0;
my $EXPORT = 0;
my $PRINT_DEPS = 0;
my $PRINT_MODULES = 0;
my $PORT = "posix";
my $LEXBOR_DIR = $FindBin::RealBin;

# Parse command line arguments
GetOptions(
    'help' => sub {
        help_message();
        exit 0;
    },
    'all' => \$ALL,
    'port=s' => \$PORT,
    'with-export-symbols' => \$EXPORT,
    'print-dependencies' => \$PRINT_DEPS,
    'print-modules' => \$PRINT_MODULES,
) or die "Error parsing args";

# Create Single instance
my $single = new Single($LEXBOR_DIR, \@ARGV, $ALL, $PORT, $EXPORT);

# Print information about modules
if ($PRINT_DEPS) {
    $single->print_modules_dependencies($single->original_modules());
    exit 0;
}

# Print all modules
if ($PRINT_MODULES) {
    my @modules;
    my $dirpath = catfile($LEXBOR_DIR, "source", "lexbor");
    die "I can't find the directory with the lexbor source code: $dirpath."
        unless -d $dirpath;

    opendir my $dh, $dirpath or die "Cannot open $dirpath: $!";

    while (my $sub = readdir $dh) {
        next if $sub =~ /^\./;
        next if $sub eq "ports";

        push @modules, $sub;
    }

    closedir $dh;

    print join(" ", sort { $a cmp $b } @modules), "\n";

    exit 0;
}

# Fix order of some headers
$single->reorder_headers_by_template(['core/def.h', 'core/types.h',
                                      'core/lexbor.h', 'core/base.h']);
$single->remove_includes_by_template(['sanitizer/asan_interface.h',
                                      'sys/sysctl.h', 'sys/stat.h', 'sys/types.h']);

# Generate single files
my $license = $single->read_license_file();
my $defines = $single->defines();
my $i_generate = $single->i_generate();
my $h_generate = $single->h_generate();
my $r_generate = $single->r_generate();
my $c_generate = $single->c_generate();

my $current_year = (localtime)[5] + 1900;
my $localtime = scalar(localtime);
my $modules = join "\n *", @{$single->print_array_wrapped($single->original_modules(1), 70, 4)};
my $dependencies = join "\n *", @{$single->print_array_wrapped($single->modules(1, 1), 65, 4)};
my $lexbor_version = $single->lexbor_version();

# Print copyright, generated file header
print <<END;
/*
 * Copyright (C) 2018-$current_year Alexander Borisov
 *
 * Author: Alexander Borisov <borisov\@lexbor.com>
 *
 * This file is generated automatically. Do not edit!
 *
 * Generated by: $FindBin::Script
 * Project: Lexbor (https://lexbor.com/)
 * GitHub: https://github.com/lexbor/lexbor
 * Date: $localtime
 * Version: $lexbor_version
 * License: Apache License Version 2.0
 * Modules: $modules
 * Dependencies: $dependencies
 */

END

# Print license
print "/* LICENSE:\n";
print join("\n", @$license);
print "\n */\n\n";

# Print defines
print "/*\n";
print " * Defines:\n";
print " */\n";
print join("\n", @$defines);
print "\n\n";

# Print includes
print "/*\n";
print " * Includes:\n";
print " */\n";
print join("\n", @$i_generate);
print "\n\n";

# Print headers
print "/*\n";
print " * Headers:\n";
print " */\n";
print join("\n", @$h_generate);
print "\n\n";

# Print resources
print "/*\n";
print " * Resources:\n";
print " */\n";
print join("\n", @$r_generate);
print "\n\n";

# Print code
print "/*\n";
print " * Source Code:\n";
print " */\n";
print join("\n", @$c_generate);
print "\n";


sub help_message
{
    print "Usage: $FindBin::Script [options] <module1> <module2> ...\n\n";
    print "Options:\n";
    print "  --help                        Show this help message\n";
    print "  --all                         Include all modules if no modules specified\n";
    print "  --port=<port>                 Specify the port (in source/lexbor/ports) to use (default: posix)\n";
    print "  --with-export-symbols         Export symbols\n";
    print "  --print-dependencies          Print dependencies of specified modules\n";
    print "  --print-modules               Print all modules\n";
}

package Single;

use utf8;
use FindBin;
use File::Spec::Functions;
use warnings FATAL => 'all';

sub new
{
    my ($class, $lexbor_dir, $modules, $all, $port, $export_symbols) = @_;
    my ($self, $dirpath, $cc, $original_modules, $port_path);

    $dirpath = catfile($lexbor_dir, "source", "lexbor");
    die "I can't find the directory with the lexbor source code: $dirpath."
        unless -d $dirpath;

    # If no modules specified, get all modules
    if ($all && !@$modules) {
        opendir my $dh, $dirpath or die "Cannot open $dirpath: $!";

        while (my $sub = readdir $dh) {
            next if $sub =~ /^\./;
            next if $sub eq "ports";

            push @$modules, $sub;
        }

        closedir $dh;
    }

    $port //= "posix";
    $dirpath = catfile($lexbor_dir, "source", "lexbor");
    $original_modules = [@$modules];
    $port_path = catfile($dirpath, "ports", $port);

    die "I can't find the directory with the port source code: $port"
        unless -d $port_path;

    push @$modules, "ports/$port";

    # Remove duplicate modules
    my %seen;
    $modules = [grep { !$seen{$_}++ } @$modules];

    if ($dirpath =~ /\\$|\/$/) {
        chop $dirpath;
    }

    die "I can't find the directory with the lexbor source code."
        unless -d $dirpath;

    $self = {
        lexbor => $lexbor_dir,
        source => $dirpath,
        port => $port,
        modules => $modules,
        modules_h => {},
        modules_c => {},
        original_modules => $original_modules,
        dependencies => {},
        res => [],
        h_index => {},
        headers => {},
        sources => {},
        includes => {},
        resources => {},
        versions => {},
        export_symbols => $export_symbols
    };

    bless $self, $class;

    $self->dependencies();
    $self->c_dependencies();
    $self->sort_dependencies();
    $self->resolve_dependencies();

    my ($headers, $sources, $includes, $resources) = $self->compile_sources();

    $self->{headers} = $headers;
    $self->{sources} = $sources;
    $self->{includes} = $includes;
    $self->{resources} = $resources;
    $self->{versions} = $self->parse_all_versions();

    return $self;
}

sub resolve_dependencies
{
    my $self = shift;
    my $dependencies = $self->{dependencies};

    foreach my $module (@{$self->{modules}}) {
        my ($internal, $other, $modules_all) = $self->resolve_recursive_dependencies($module);
        $dependencies->{$module}->{internal_all} = $internal;
        $dependencies->{$module}->{other_all} = $other;
        $dependencies->{$module}->{modules_all} = $modules_all;
    }
}

sub resolve_recursive_dependencies
{
    my ($self, $module, $res_internal, $res_other, $res_modules) = @_;

    my $dependencies = $self->{dependencies};
    my $modules = $dependencies->{$module}->{modules};

    $res_internal //= [];
    $res_other //= [];
    $res_modules //= [];

    foreach my $h (@{$dependencies->{$module}->{internal}}) {
        unless (grep { $_ eq $h } @$res_internal) {
            push @$res_internal, $h;
        }
    }

    foreach my $h (@{$dependencies->{$module}->{other}}) {
        unless (grep { $_ eq $h } @$res_other) {
            push @$res_other, $h;
        }
    }

    foreach my $dep_module (@$modules) {
        unless (grep { $_ eq $dep_module } @$res_modules) {
            push @$res_modules, $dep_module;

            $self->resolve_recursive_dependencies($dep_module, $res_internal, $res_other, $res_modules);
        }
    }

    return ($res_internal, $res_other, $res_modules);
}

sub c_dependencies
{
    my $self = shift;

    foreach my $module (@{$self->{modules}}) {
        my $deps = $self->{dependencies}->{$module};
        $deps->{source_all} = $self->resolve_c_recursive_dependencies($module);
    }
}

sub resolve_c_recursive_dependencies
{
    my ($self, $module, $res, $index, $index_c) = @_;

    my $dependencies = $self->{dependencies};
    my $modules = $dependencies->{$module}->{modules};

    $res //= [];
    $index //= {};
    $index_c //= {};
    $index->{$module} = 1;

    foreach my $c (@{$self->{modules_c}->{$module}}) {
        my $sub_path = catfile($module, $c);

        next if exists $index_c->{$sub_path};
        $index_c->{$sub_path} = 1;

        push @$res, $sub_path;
    }

    foreach my $dep_module (@$modules) {
        next if exists $index->{$dep_module};

        $self->resolve_c_recursive_dependencies($dep_module, $res, $index, $index_c);
    }

    return $res;
}

sub dependencies
{
    my $self = shift;

    my $need_deps = 0;
    my $dependencies = $self->{dependencies};
    my $modules_c = $self->{modules_c};

    foreach my $module (@{$self->{modules}}) {
        next if exists $dependencies->{$module};

        $self->index_source($module);

        my ($internal, $other, $dep_modules) = $self->module_dependencies($module);

        $dependencies->{$module} = {
            # Internal include (.h) dependencies, only start with "lexbor/"
            internal => $internal,
            # Other include (.h) dependencies
            other => $other,
            # Source files (.c) dependencies
            source => $self->subpath_sources($module),
            # Module dependencies
            modules => $dep_modules,
            # Recursive internal include (.h) dependencies, only start with "lexbor/"
            internal_all => [],
            # Recursive other include (.h) dependencies
            other_all => [],
            # Recursive source files (.c) dependencies
            source_all => [],
            # Recursive module dependencies
            modules_all => []
        };

        foreach my $dep_module (@$dep_modules) {
            unless (grep { $_ eq $dep_module } @{$self->{modules}}) {
                push @{$self->{modules}}, $dep_module;
                $need_deps = 1;
            }
        }
    }

    if ($need_deps) {
        $self->dependencies();
    }

    return $dependencies;
}

sub subpath_sources
{
    my ($self, $module) = @_;

    my $sources = [];
    my $modules_c = $self->{modules_c};

    foreach my $c (@{$modules_c->{$module}}) {
        push @$sources, catfile($module, $c);
    }

    return $sources;
}

sub module_dependencies
{
    my ($self, $module) = @_;

    my $internal = {};
    my $other = {};
    my $dep_modules = {};
    my $index = $self->{h_index};
    my $modules_h = $self->{modules_h};
    my $modules_c = $self->{modules_c};

    foreach my $h (@{$modules_h->{$module}}, @{$modules_c->{$module}}) {
        my $full_path = catfile($self->{source}, $module, $h);
        my $deps = $self->source_dependencies($full_path);

        foreach my $dep (@$deps) {
            if ($dep =~ /^lexbor\//) {
                $dep =~ s/^lexbor\///;

                $internal->{$dep} = 1;

                my $h_full = catfile($module, $h);
                $index->{$h_full}->{$dep} = 1 if $h =~ /\.h$/;

                my @entries = split /\//, $dep;
                my $dep_module = defined $entries[0] ? $entries[0] : "";
                $dep_modules->{$dep_module} = 1
                    if $dep_module ne $module;
            }
            else {
                $other->{$dep} = 1;
            }
        }
    }

    return ([sort { $a cmp $b } keys %$internal],
            [sort { $a cmp $b } keys %$other],
            [sort { $a cmp $b } keys %$dep_modules]);
}

sub source_dependencies
{
    my ($self, $path) = @_;
    my ($depends);

    $depends = [];

    open my $fh, "<:encoding(UTF-8)", $path
        or die "Cannot open the file ($path): $!";

    while (my $line = <$fh>) {
        $line =~ s/^\s+|\s+$//g;

        if ($line =~ /\#include\s*<([^>]+)>/) {
           push @$depends, $1 unless grep { $_ eq $1 } @$depends;
        }
        elsif ($line =~ /\#include\s*"([^"]+)"/) {
            push @$depends, $1 unless grep { $_ eq $1 } @$depends;
        }
        elsif ($line =~ /\#include/) {
            die "Cannot parse include line: $line in file $path";
        }
    }

    return $depends;
}

sub sort_dependencies
{
    my $self = shift;
    my $dependencies = $self->{dependencies};

    foreach my $module (keys %$dependencies) {
        my $dep = $dependencies->{$module};

        @{$dep->{internal}} = sort { $a cmp $b } @{$dep->{internal}};
        @{$dep->{other}} = sort { $a cmp $b } @{$dep->{other}};
        @{$dep->{source}} = sort { $a cmp $b } @{$dep->{source}};
        @{$dep->{modules}} = sort { $a cmp $b } @{$dep->{modules}};
        @{$dep->{internal_all}} = sort { $a cmp $b } @{$dep->{internal_all}};
        @{$dep->{other_all}} = sort { $a cmp $b } @{$dep->{other_all}};
        @{$dep->{source_all}} = sort { $a cmp $b } @{$dep->{source_all}};
        @{$dep->{modules_all}} = sort { $a cmp $b } @{$dep->{modules_all}};
    }
}

sub index_source_files
{
    my $self = shift;
    my $modules = $self->{modules};

    foreach my $module (@$modules) {
        $self->index_source($module);
    }
}

sub index_source
{
    my ($self, $module) = @_;

    my $modules_h = $self->{modules_h};
    my $modules_c = $self->{modules_c};

    # Find module path
    my $path = catfile($self->{source}, $module);
    if (!-d $path) {
        die "Module '$module' not found.";
    }

    my ($headers, $code) = $self->walk($path);

    # Sort found files
    @$headers = sort { $a cmp $b } @$headers;
    @$code = sort { $a cmp $b } @$code;

    $modules_h->{$module} //= [];
    $modules_c->{$module} //= [];

    # Store found files
    push @{$modules_h->{$module}}, @$headers;
    push @{$modules_c->{$module}}, @$code;
}

sub walk
{
    my ($self, $source, $sub_path, $headers, $code) = @_;
    my ($full_path, $sub_path_local);

    $headers //= [];
    $code //= [];
    $sub_path //= "";

    opendir my $dh, $source or die "Cannot open $source: $!";

    while (my $sub = readdir $dh) {
        next if $sub =~ /^\./;

        $full_path = catfile($source, $sub);
        $sub_path_local = catfile($sub_path, $sub);

        $sub_path_local =~ s/^\\+|^\/+//;
        next if $sub_path_local =~ /^ports/;

        if (!-d $full_path) {
            if ($sub =~ /\.h$/) {
                push @$headers, $sub_path_local;
            }
            elsif ($sub =~ /\.c$/) {
                push @$code, $sub_path_local;
            }
        }

        $self->walk($full_path, $sub_path_local, $headers, $code)
            if -d $full_path;
    }

    closedir $dh;

    return ($headers, $code);
}

sub compile_sources
{
    my $self = shift;
    my ($headers, $sources, $dependencies, $internal, $source, $sub_paths);
    my ($includes, @resources, $is_wout_deps);

    $is_wout_deps = $self->{without_dependencies};
    $internal = $is_wout_deps ? "internal" : "internal_all";
    $source = $is_wout_deps ? "source" : "source_all";
    $dependencies = $self->{dependencies};

    $headers = {};
    $sources = {};
    $includes = {};

    foreach my $module (@{$self->{modules}}) {
        $sub_paths = $dependencies->{$module}->{$internal};
        $headers->{$_} = 1 foreach (@$sub_paths);

        $sub_paths = $dependencies->{$module}->{$source};
        $sources->{$_} = 1 foreach (@$sub_paths);

        $includes->{$_} = 1 foreach (@{$dependencies->{$module}->{other_all}});
    }

    $headers = [keys %$headers];
    $sources = [sort { $a cmp $b } keys %$sources];
    $includes = [sort { $a cmp $b } keys %$includes];

    $headers = $self->sort_headers_by_dependencies($self->{h_index}, $headers);

    # Extract resources from headers
    foreach my $idx (0..$#$headers) {
        my $sub_path = $headers->[$idx];

        if ($sub_path =~ /res\.h$/) {
            push @resources, delete $headers->[$idx];
        }
    }

    $headers = [grep { defined $_ } @$headers];

    # Extract resources from sources
    foreach my $idx (0..$#$sources) {
        my $sub_path = $sources->[$idx];

        if ($sub_path =~ /res\.c$/) {
            push @resources, delete $sources->[$idx];
        }
    }

    $sources = [grep { defined $_ } @$sources];

    return ($headers, $sources, $includes, \@resources);
}

sub sort_headers_by_dependencies {
    my ($self, $index, $headers) = @_;

    my %header_set = map { $_ => 1 } @$headers;

    my %visited;
    my %in_stack;
    my @result;

    my $visit;
    $visit = sub {
        my ($header) = @_;

        return if $visited{$header};
        return if $in_stack{$header};

        $in_stack{$header} = 1;

        if (exists $index->{$header}) {
            for my $dep (sort keys %{$index->{$header}}) {
                if ($header_set{$dep}) {
                    $visit->($dep);
                }
            }
        }

        delete $in_stack{$header};
        $visited{$header} = 1;

        push @result, $header;
    };

    for my $header (sort @$headers) {
        $visit->($header);
    }

    return \@result;
}

sub r_generate
{
    my $self = shift;
    my (@res, $resources);

    $resources = $self->{resources};

    foreach my $idx (0..$#$resources) {
        my $file_path = $resources->[$idx];

        push @res, "/* Resource: $file_path */\n";
        push @res, @{$self->process_h_file($file_path, 2)};

        if ($idx != $#$resources) {
            push @res, "";
        }
    }

    return \@res;
}

sub i_generate
{
    my $self = shift;
    my @res;
    my $includes = $self->{includes};

    foreach my $idx (0..$#$includes) {
        my $file_path = $includes->[$idx];

        push @res, "#include <$file_path>";
    }

    return \@res;
}

sub h_generate
{
    my $self = shift;
    my @res;

    my $headers_files = $self->{headers};

    foreach my $idx (0..$#$headers_files) {
        my $file_path = $headers_files->[$idx];
        my $path = catfile("source", "lexbor", $file_path);

        push @res, "/* Header: $path */\n";
        push @res, @{$self->process_h_file($file_path, 2)};

        if ($idx != $#$headers_files) {
            push @res, "";
        }
    }

    return \@res;
}

sub process_h_file
{
    my ($self, $file_path, $ncount) = @_;
    my ($full_path, $res);

    $full_path = catfile($self->{source}, $file_path);

    open my $fh, "<:encoding(UTF-8)", $full_path
        or die "Cannot open the file ($full_path): $!";

    my $include_guards = 0;
    my @cplusplus;
    my $have_extern_c = 0;
    $ncount //= 0;
    $res = [];

    while (my $line = <$fh>) {
        my $tmp = $line;

        $tmp =~ s/\s+$//g;

        # Remove copyright comments in beginning of file
        if (@$res == 0 &&
            ($tmp =~ /^\s*$/
            || $tmp =~ /^\s*\/\*/
            || $tmp =~ /^\s*\*/))
        {
            next;
        }

        # Remove include guards
        if ($include_guards == 0 && @$res == 0 && $tmp =~ /^\s*#ifndef\s+(LEXBOR[A-Z0-9_]+)$/) {
            my $guard_name = $1;
            $tmp = <$fh>;
            $tmp =~ /^\s*#define\s+$guard_name\s*$/
                or die "Cannot parse include guard in file $full_path";

            $include_guards = 1;
            next;
        }

        # Remove cplusplus guards
        if ($tmp =~ /^\s*#ifdef\s+__cplusplus/) {
            push @cplusplus, $tmp;
            next;
        }
        if (@cplusplus) {
            push @cplusplus, $tmp;

            if ($tmp =~ /^\s*extern\s*"C"/) {
                $have_extern_c = 1;
            }
            elsif ($tmp =~ /^\s*#endif/) {
                unless ($have_extern_c) {
                    push @$res, @cplusplus;
                }

                @cplusplus = ();
                $have_extern_c = 0;
            }

            next;
        }

        # Remove lexbor includes
        # Other includes are retained because we don't know what might be
        # there; they are external or systemic.
        if ($tmp =~ /\#include\s*<([^>]+)>/
            || $tmp =~ /\#include\s*"([^"]+)"/)
        {
            next if $1 =~ /^lexbor\//;
        }
        elsif ($tmp =~ /\#include/) {
            die "Cannot parse include line: $tmp in file $full_path";
        }

        # Remove multiple empty lines (only more than 2)
        if ($tmp eq "") {
            $ncount += 1;
        }
        else {
            $ncount = 0;
        }
        next if $ncount > 2;

        push @$res, $tmp;
    }

    close $fh;

    # Remove lexbor include guard from end of file
    for (my $i = $#$res; $i >= 0; $i--) {
        next if $res->[$i] =~ /^\s*$/;

        if ($res->[$i] =~ /^\s*#endif\s*\/\*\s*LEXBOR/) {
            splice(@$res, $i);
        }

        last;
    }

    # Remove cplusplus guards from end of file
    my $found_start = -1;
    my $stage = 0;

    for (my $i = $#$res; $i >= 0; $i--) {
        my $line = $res->[$i];

        next if $line =~ /^\s*$/;

        if ($stage == 0) {
            if ($line =~ /^\s*#endif\s*$/) {
                $stage = 1;
            } else {
                last;
            }
        }
        elsif ($stage == 1) {
            if ($line =~ /^\s*\}/) {
                $stage = 2;
            } else {
                last;
            }
        }
        elsif ($stage == 2) {
            if ($line =~ /^\s*#ifdef\s*__cplusplus\s*$/) {
                $found_start = $i;
                last;
            } else {
                last;
            }
        }
    }

    if ($found_start != -1) {
        splice(@$res, $found_start);
    }

    # Remove trailing empty lines
    pop @$res while (@$res && $res->[-1] =~ /^\s*$/);

    return $res;
}

sub c_generate
{
    my $self = shift;
    my @res;

    my $source_files = $self->{sources};

    foreach my $idx (0..$#$source_files) {
        my $file_path = $source_files->[$idx];

        push @res, @{$self->process_c_file($file_path, 2)};

        if ($idx != $#$source_files) {
            push @res, "";
        }
    }

    return \@res;
}

sub process_c_file
{
    my ($self, $file_path, $ncount) = @_;
    my ($full_path, $res);

    $full_path = catfile($self->{source}, $file_path);

    open my $fh, "<:encoding(UTF-8)", $full_path
        or die "Cannot open the file ($full_path): $!";

    $ncount //= 0;
    $res = [];

    while (my $line = <$fh>) {
        my $tmp = $line;

        $tmp =~ s/\s+$//g;

        # Remove copyright comments in beginning of file
        if (($tmp =~ /^\s*$/
            || $tmp =~ /^\s*\/\*/
            || $tmp =~ /^\s*\*/) && @$res == 0)
        {
            next;
        }

        # Remove lexbor includes
        # Other includes are retained because we don't know what might be
        # there; they are external or systemic.
        if ($tmp =~ /\#include\s*<([^>]+)>/
            || $tmp =~ /\#include\s*"([^"]+)"/)
        {
            next if $1 =~ /^lexbor\//;
        }
        elsif ($tmp =~ /\#include/) {
            die "Cannot parse include line: $tmp in file $full_path";
        }

        # Remove multiple empty lines (only more than 2)
        if ($tmp eq "") {
            $ncount += 1;
        }
        else {
            $ncount = 0;
        }
        next if $ncount > 2;

        push @$res, $tmp;
    }

    close $fh;

    # Remove trailing empty lines
    pop @$res while (@$res && $res->[-1] =~ /^\s*$/);

    return $res;
}

sub reorder_headers_by_template
{
    my ($self, $template) = @_;

    $self->{headers} = reorder_by_template($self->{headers}, $template);
}

sub reorder_by_template
{
    my ($source, $template) = @_;

    my %reserved;
    for my $val (@$template) {
        $reserved{$val}++ if defined $val;
    }

    my @free = grep {
        not (defined $_ && $reserved{$_} && $reserved{$_}--)
    } @$source;

    my @result;
    my $free_idx = 0;

    for my $i (0 .. $#$template) {
        if (defined $template->[$i]) {
            $result[$i] = $template->[$i];
        } else {
            $result[$i] = $free[$free_idx++] if $free_idx < @free;
        }
    }

    push @result, @free[$free_idx .. $#free] if $free_idx <= $#free;

    return \@result;
}

sub remove_includes_by_template
{
    my ($self, $template) = @_;

    my $includes = $self->{includes};
    my %exclude_map = map { $_ => 1 } @$template;

    $self->{includes} = [grep { !exists $exclude_map{$_} } @$includes];
}

sub read_license_file
{
    my $self = shift;
    my ($res, $full_path);

    $full_path = catfile($self->{lexbor}, "LICENSE");

    open my $fh, "<:encoding(UTF-8)", $full_path
        or die "Cannot open the file ($full_path): $!";

    $res = [];

    while (my $line = <$fh>) {
        $line =~ s/\s+$//g;
        push @$res, $line;
    }

    close $fh;

    return $res;
}

sub original_modules
{
    my ($self, $with_version) = @_;

    if ($with_version) {
        my $versions = $self->{versions};
        my @modules = @{$self->{original_modules}};

        for my $i (0 .. $#modules) {
            my $mod = $modules[$i];
            if (exists $versions->{$mod}) {
                my $ver = $versions->{$mod};
                $modules[$i] = sprintf("%s-%d.%d.%d", $mod, $ver->[0],
                                                      $ver->[1], $ver->[2]);
            }
        }

        return [sort {$a cmp $b} @modules];
    }

    return [sort {$a cmp $b} @{$_[0]->{original_modules}}];
}

sub modules
{
    my ($self, $without_originals, $with_version) = @_;

    my @modules = @{$self->{modules}};

    if ($without_originals) {
        my %originals = map { $_ => 1 } @{$self->{original_modules}};
        @modules = grep { not $originals{$_} } @modules;
    }

    if ($with_version) {
        my $versions = $self->{versions};

        for my $i (0 .. $#modules) {
            my $mod = $modules[$i];
            if (exists $versions->{$mod}) {
                my $ver = $versions->{$mod};
                $modules[$i] = sprintf("%s-%d.%d.%d", $mod, $ver->[0],
                                                      $ver->[1], $ver->[2]);
            }
        }
    }

    return [sort {$a cmp $b} @modules];
}

sub print_modules_dependencies
{
    my ($self, $modules) = @_;

    foreach my $idx (0..$#$modules) {
        my $module = $modules->[$idx];

        print "Module: $module\n";

        $self->print_dependencies($module);

        print "\n" if ($idx != $#$modules);
    }
}

sub print_dependencies
{
    my ($self, $module, $ident) = @_;

    $ident //= 4;

    my $dependencies = $self->{dependencies};
    my $dep = $dependencies->{$module};
    my $witspace = " " x $ident;

    print "$witspace"."Internal Headers:\n";
    foreach my $h (@{$dep->{internal}}) {
        print "$witspace    $h\n";
    }

    print "$witspace"."Other Headers:\n";
    foreach my $h (@{$dep->{other}}) {
        print "$witspace    $h\n";
    }

    print "$witspace"."Source files:\n";
    foreach my $h (@{$dep->{source}}) {
        print "$witspace    $h\n";
    }

    print "$witspace"."Modules:\n";
    foreach my $m (@{$dep->{modules}}) {
        print "$witspace    $m\n";
    }

    print "$witspace"."Internal Headers with recursive dependencies:\n";
    foreach my $m (@{$dep->{internal_all}}) {
        print "$witspace    $m\n";
    }

    print "$witspace"."Other Headers with recursive dependencies:\n";
    foreach my $m (@{$dep->{other_all}}) {
        print "$witspace    $m\n";
    }

    print "$witspace"."Source files with recursive dependencies:\n";
    foreach my $h (@{$dep->{source_all}}) {
        print "$witspace    $h\n";
    }

    print "$witspace"."Modules with recursive dependencies:\n";
    foreach my $m (@{$dep->{modules_all}}) {
        print "$witspace    $m\n";
    }
}

sub defines
{
    my $self = shift;
    my @defines;

    push @defines, "#define LEXBOR_BUILDING_STATIC";
    push @defines, "#define LEXBOR_STATIC" unless $self->{export_symbols};

    if ($self->{port} eq "posix") {
        push @defines, "#define _POSIX_C_SOURCE 199309L";

        push @defines, "#ifndef _DEFAULT_SOURCE";
        push @defines, "#define _DEFAULT_SOURCE";
        push @defines, "#endif";

        push @defines, "#ifndef _BSD_SOURCE";
        push @defines, "#define _BSD_SOURCE";
        push @defines, "#endif";
    }

    return \@defines;
}

sub lexbor_version
{
    my $self = shift;

    open my $fh, "<:encoding(UTF-8)", catfile($self->{lexbor}, "version")
        or die "Cannot open VERSION file: $!";
    my $version = <$fh>;
    close $fh;

    $version =~ s/^LEXBOR_VERSION=//;
    $version =~ s/^\s+|\s+$//g;

    return $version;
}

sub versions
{
    return $_[0]->{versions};
}

sub parse_all_versions
{
    my ($self) = @_;
    my %versions;

    foreach my $module (@{$self->{modules}}) {
        next if $module =~ /^ports\//;
        $versions{$module} = $self->parse_version($module);
    }

    return \%versions;
}

sub parse_version
{
    my ($self, $module) = @_;

    my $path = catfile($self->{source}, $module, "base.h");

    open my $fh, '<', $path or die "Can't open '$path': $!";

    my %ver;

    while (my $line = <$fh>) {
        # #define LXB_ENCODING_VERSION_MAJOR 2
        if ($line =~ /^\s*#define\s+LXB_\w+_VERSION_(MAJOR|MINOR|PATCH)\s+(\d+)\b/) {
            my ($part, $num) = (lc($1), 0 + $2);
            $ver{$part} = $num;
        }
        elsif ($line =~ /^\s*#define\s+LEXBOR_VERSION_(MAJOR|MINOR|PATCH)\s+(\d+)\b/) {
            my ($part, $num) = (lc($1), 0 + $2);
            $ver{$part} = $num;
        }
    }

    close $fh;

    die "Version information not found in '$path'" unless
        exists $ver{major} && exists $ver{minor} && exists $ver{patch};

    return [$ver{major}, $ver{minor}, $ver{patch}];
}

sub print_array_wrapped {
    my ($self, $vals, $max_width, $ident) = @_;
    my $line = '';
    my @res;

    $ident ||= 0;
    $max_width ||= 80;

    $ident = ' ' x $ident if defined $ident;

    $line = $vals->[0] if scalar @$vals;

    for (my $idx = 1; $idx <scalar @$vals; $idx++) {
        my $v = $vals->[$idx];
        my $chunk = length($line) ? ", $v" : "$ident$v";

        if (length($line) + length($chunk) > $max_width) {
            push @res, "$line" if length $line;
            $line = "";
            $idx -= 1; # Re-process this value
        }
        else {
            $line .= $chunk;
        }
    }

    push @res, "$line" if length $line;

    return \@res;
}
